/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.7.0 (NJsonSchema v10.6.7.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    getAccounts(query: AccountsQuery , cancelToken?: CancelToken | undefined): Promise<ListResultOfAccountsViewModel> {
        let url_ = this.baseUrl + "/api/accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccounts(_response);
        });
    }

    protected processGetAccounts(response: AxiosResponse): Promise<ListResultOfAccountsViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultOfAccountsViewModel.fromJS(resultData200);
            return Promise.resolve<ListResultOfAccountsViewModel>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultOfAccountsViewModel>(null as any);
    }

    getAccount(accountName: string | null , cancelToken?: CancelToken | undefined): Promise<AccountsViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{accountName}";
        if (accountName === undefined || accountName === null)
            throw new Error("The parameter 'accountName' must be defined.");
        url_ = url_.replace("{accountName}", encodeURIComponent("" + accountName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccount(_response);
        });
    }

    protected processGetAccount(response: AxiosResponse): Promise<AccountsViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountsViewModel.fromJS(resultData200);
            return Promise.resolve<AccountsViewModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountsViewModel>(null as any);
    }

    createAccount(model: CreateAccountPostModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAccount(_response);
        });
    }

    protected processCreateAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteAccount(username: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    lockAccount(username: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/{username}/lock";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLockAccount(_response);
        });
    }

    protected processLockAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    assignUsers(model: AssignUsersPostModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/assign-users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignUsers(_response);
        });
    }

    protected processAssignUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    updateActivity(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/update-activity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    accountPnl(account: string | null , cancelToken?: CancelToken | undefined): Promise<PnlResponseModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/pnl";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountPnl(_response);
        });
    }

    protected processAccountPnl(response: AxiosResponse): Promise<PnlResponseModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PnlResponseModel.fromJS(resultData200);
            return Promise.resolve<PnlResponseModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PnlResponseModel>(null as any);
    }

    accountPortfolio(account: string | null , cancelToken?: CancelToken | undefined): Promise<UpdatePortfolioMessage[]> {
        let url_ = this.baseUrl + "/api/accounts/{account}/portfolio";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountPortfolio(_response);
        });
    }

    protected processAccountPortfolio(response: AxiosResponse): Promise<UpdatePortfolioMessage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UpdatePortfolioMessage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UpdatePortfolioMessage[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdatePortfolioMessage[]>(null as any);
    }
}

export class AuthorizationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    login(model: LoginRequestModel , cancelToken?: CancelToken | undefined): Promise<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/authorization/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginResponseModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResponseModel.fromJS(resultData200);
            return Promise.resolve<LoginResponseModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResponseModel>(null as any);
    }

    createUser(request: CreateUserRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorResultModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    getUsers(  cancelToken?: CancelToken | undefined): Promise<ApplicationUserViewModel[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<ApplicationUserViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationUserViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ApplicationUserViewModel[]>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationUserViewModel[]>(null as any);
    }
}

export class ContainersManagementClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    getContainerStatus(account: string | null , cancelToken?: CancelToken | undefined): Promise<ContainerStatusViewModel> {
        let url_ = this.baseUrl + "/api/containers-management/{account}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContainerStatus(_response);
        });
    }

    protected processGetContainerStatus(response: AxiosResponse): Promise<ContainerStatusViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContainerStatusViewModel.fromJS(resultData200);
            return Promise.resolve<ContainerStatusViewModel>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContainerStatusViewModel>(null as any);
    }

    deleteContainer(account: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/containers-management/{account}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteContainer(_response);
        });
    }

    protected processDeleteContainer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createContainer(account: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/containers-management/{account}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateContainer(_response);
        });
    }

    protected processCreateContainer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    startContainer(account: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/containers-management/{account}/start";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStartContainer(_response);
        });
    }

    protected processStartContainer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    stopContainer(account: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/containers-management/{account}/stop";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStopContainer(_response);
        });
    }

    protected processStopContainer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAllContainers(  cancelToken?: CancelToken | undefined): Promise<ContainerDetailsModel[]> {
        let url_ = this.baseUrl + "/api/containers-management";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllContainers(_response);
        });
    }

    protected processGetAllContainers(response: AxiosResponse): Promise<ContainerDetailsModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerDetailsModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContainerDetailsModel[]>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContainerDetailsModel[]>(null as any);
    }
}

export class DummyClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    getTickModel(  cancelToken?: CancelToken | undefined): Promise<TickModel> {
        let url_ = this.baseUrl + "/api/Dummy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTickModel(_response);
        });
    }

    protected processGetTickModel(response: AxiosResponse): Promise<TickModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TickModel.fromJS(resultData200);
            return Promise.resolve<TickModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TickModel>(null as any);
    }

    calcShareQuantity(price: number | undefined, multipler: number | undefined, size: number | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Dummy/qty?";
        if (price === null)
            throw new Error("The parameter 'price' cannot be null.");
        else if (price !== undefined)
            url_ += "price=" + encodeURIComponent("" + price) + "&";
        if (multipler === null)
            throw new Error("The parameter 'multipler' cannot be null.");
        else if (multipler !== undefined)
            url_ += "multipler=" + encodeURIComponent("" + multipler) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCalcShareQuantity(_response);
        });
    }

    protected processCalcShareQuantity(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class OrdersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    get(account: string | null, tradeId: string , cancelToken?: CancelToken | undefined): Promise<OrderViewModel[]> {
        let url_ = this.baseUrl + "/api/accounts/{account}/orders/open/{tradeId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (tradeId === undefined || tradeId === null)
            throw new Error("The parameter 'tradeId' must be defined.");
        url_ = url_.replace("{tradeId}", encodeURIComponent("" + tradeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OrderViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrderViewModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel[]>(null as any);
    }

    get2(account: string | null , cancelToken?: CancelToken | undefined): Promise<OrderViewModel[]> {
        let url_ = this.baseUrl + "/api/accounts/{account}/orders";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: AxiosResponse): Promise<OrderViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrderViewModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorResultModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel[]>(null as any);
    }

    post(account: string | null, postModel: CreateOrderPostModel , cancelToken?: CancelToken | undefined): Promise<OrderViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/orders";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<OrderViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderViewModel.fromJS(resultData200);
            return Promise.resolve<OrderViewModel>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel>(null as any);
    }

    put(account: string | null, orderId: number, postModel: CreateOrderPostModel , cancelToken?: CancelToken | undefined): Promise<OrderViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/orders/{orderId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<OrderViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderViewModel.fromJS(resultData200);
            return Promise.resolve<OrderViewModel>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel>(null as any);
    }

    delete(account: string | null, orderId: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/{account}/orders/{orderId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class QuotesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    quotes(account: string | null, quotes: QuoteQuery[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<GetQuotesForSymbolsResult> {
        let url_ = this.baseUrl + "/api/accounts/{account}/quotes/quotes?";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (quotes !== undefined && quotes !== null)
            quotes && quotes.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Quotes[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuotes(_response);
        });
    }

    protected processQuotes(response: AxiosResponse): Promise<GetQuotesForSymbolsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetQuotesForSymbolsResult.fromJS(resultData200);
            return Promise.resolve<GetQuotesForSymbolsResult>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetQuotesForSymbolsResult>(null as any);
    }

    expirations(account: string | null, secType: string | null, symbol: string | null , cancelToken?: CancelToken | undefined): Promise<ExpirationsResponseModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/quotes/opt/{secType}/{symbol}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (secType === undefined || secType === null)
            throw new Error("The parameter 'secType' must be defined.");
        url_ = url_.replace("{secType}", encodeURIComponent("" + secType));
        if (symbol === undefined || symbol === null)
            throw new Error("The parameter 'symbol' must be defined.");
        url_ = url_.replace("{symbol}", encodeURIComponent("" + symbol));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExpirations(_response);
        });
    }

    protected processExpirations(response: AxiosResponse): Promise<ExpirationsResponseModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExpirationsResponseModel.fromJS(resultData200);
            return Promise.resolve<ExpirationsResponseModel>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExpirationsResponseModel>(null as any);
    }

    optionsMatrixData(account: string | null, strikeOffset: number | undefined, page: number | undefined, secType: string | null | undefined, symbol: string | null | undefined, strike: number | null | undefined, right: string | null | undefined, expirationDate: string | null | undefined, exchange: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<OptionsWatchlistData[]> {
        let url_ = this.baseUrl + "/api/accounts/{account}/quotes/opt/quote?";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (strikeOffset === null)
            throw new Error("The parameter 'strikeOffset' cannot be null.");
        else if (strikeOffset !== undefined)
            url_ += "StrikeOffset=" + encodeURIComponent("" + strikeOffset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (secType !== undefined && secType !== null)
            url_ += "SecType=" + encodeURIComponent("" + secType) + "&";
        if (symbol !== undefined && symbol !== null)
            url_ += "Symbol=" + encodeURIComponent("" + symbol) + "&";
        if (strike !== undefined && strike !== null)
            url_ += "Strike=" + encodeURIComponent("" + strike) + "&";
        if (right !== undefined && right !== null)
            url_ += "Right=" + encodeURIComponent("" + right) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "ExpirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        if (exchange !== undefined && exchange !== null)
            url_ += "Exchange=" + encodeURIComponent("" + exchange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOptionsMatrixData(_response);
        });
    }

    protected processOptionsMatrixData(response: AxiosResponse): Promise<OptionsWatchlistData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionsWatchlistData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OptionsWatchlistData[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionsWatchlistData[]>(null as any);
    }

    quote(account: string | null, secType: string | null | undefined, symbol: string | null | undefined, strike: number | null | undefined, right: string | null | undefined, expirationDate: string | null | undefined, exchange: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<QuoteResult> {
        let url_ = this.baseUrl + "/api/accounts/{account}/quotes/quote?";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (secType !== undefined && secType !== null)
            url_ += "SecType=" + encodeURIComponent("" + secType) + "&";
        if (symbol !== undefined && symbol !== null)
            url_ += "Symbol=" + encodeURIComponent("" + symbol) + "&";
        if (strike !== undefined && strike !== null)
            url_ += "Strike=" + encodeURIComponent("" + strike) + "&";
        if (right !== undefined && right !== null)
            url_ += "Right=" + encodeURIComponent("" + right) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "ExpirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        if (exchange !== undefined && exchange !== null)
            url_ += "Exchange=" + encodeURIComponent("" + exchange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuote(_response);
        });
    }

    protected processQuote(response: AxiosResponse): Promise<QuoteResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuoteResult.fromJS(resultData200);
            return Promise.resolve<QuoteResult>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuoteResult>(null as any);
    }
}

export class SymbolClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    search(account: string | null, pattern: string | null, secType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<SymbolSearchResult> {
        let url_ = this.baseUrl + "/api/accounts/{account}/search/{pattern}?";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (pattern === undefined || pattern === null)
            throw new Error("The parameter 'pattern' must be defined.");
        url_ = url_.replace("{pattern}", encodeURIComponent("" + pattern));
        if (secType !== undefined && secType !== null)
            url_ += "secType=" + encodeURIComponent("" + secType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<SymbolSearchResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SymbolSearchResult.fromJS(resultData200);
            return Promise.resolve<SymbolSearchResult>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SymbolSearchResult>(null as any);
    }
}

export class TdaOauthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    redirectToTDA(name: string | null | undefined, tradingMode: TradingMode | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/tdaoauth/redirect-to-tda?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (tradingMode === null)
            throw new Error("The parameter 'tradingMode' cannot be null.");
        else if (tradingMode !== undefined)
            url_ += "tradingMode=" + encodeURIComponent("" + tradingMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRedirectToTDA(_response);
        });
    }

    protected processRedirectToTDA(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    processsTDAAddAccountCallback(code: string | null | undefined, state: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/adtoauth/callback?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcesssTDAAddAccountCallback(_response);
        });
    }

    protected processProcesssTDAAddAccountCallback(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class TradesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7701";

    }

    getAll(account: string | null, status: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<TradeViewModel[]> {
        let url_ = this.baseUrl + "/api/accounts/{account}/trades?";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TradeViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TradeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TradeViewModel[]>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TradeViewModel[]>(null as any);
    }

    post(account: string | null, tradePost: CreateTradePostModel , cancelToken?: CancelToken | undefined): Promise<TradeViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/trades";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradePost);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<TradeViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TradeViewModel.fromJS(resultData200);
            return Promise.resolve<TradeViewModel>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TradeViewModel>(null as any);
    }

    get(account: string | null, tradeId: string , cancelToken?: CancelToken | undefined): Promise<TradeViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/trades/{tradeId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (tradeId === undefined || tradeId === null)
            throw new Error("The parameter 'tradeId' must be defined.");
        url_ = url_.replace("{tradeId}", encodeURIComponent("" + tradeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TradeViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TradeViewModel.fromJS(resultData200);
            return Promise.resolve<TradeViewModel>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TradeViewModel>(null as any);
    }

    put(account: string | null, tradeId: string, postModel: CreateTradePostModel , cancelToken?: CancelToken | undefined): Promise<TradeViewModel> {
        let url_ = this.baseUrl + "/api/accounts/{account}/trades/{tradeId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (tradeId === undefined || tradeId === null)
            throw new Error("The parameter 'tradeId' must be defined.");
        url_ = url_.replace("{tradeId}", encodeURIComponent("" + tradeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<TradeViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TradeViewModel.fromJS(resultData200);
            return Promise.resolve<TradeViewModel>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TradeViewModel>(null as any);
    }

    delete(account: string | null, tradeId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/accounts/{account}/trades/{tradeId}";
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (tradeId === undefined || tradeId === null)
            throw new Error("The parameter 'tradeId' must be defined.");
        url_ = url_.replace("{tradeId}", encodeURIComponent("" + tradeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorResultModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ListResultOfAccountsViewModel implements IListResultOfAccountsViewModel {
    totalRecords!: number;
    items?: AccountsViewModel[] | undefined;

    constructor(data?: IListResultOfAccountsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRecords = _data["totalRecords"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccountsViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultOfAccountsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfAccountsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfAccountsViewModel {
    totalRecords: number;
    items?: AccountsViewModel[] | undefined;
}

export class AccountsViewModel implements IAccountsViewModel {
    id?: string | undefined;
    username?: string | undefined;
    status!: AccountStatus;
    gatewayConnected!: boolean;
    tradingMode!: TradingMode;
    accountType!: AccountType;
    isLocked!: boolean;
    lockedByUsername?: string | undefined;
    lockedByUserId!: string;
    containerStatus?: VMContainerStatus | undefined;
    assignedUsers?: string[] | undefined;

    constructor(data?: IAccountsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.status = _data["status"];
            this.gatewayConnected = _data["gatewayConnected"];
            this.tradingMode = _data["tradingMode"];
            this.accountType = _data["accountType"];
            this.isLocked = _data["isLocked"];
            this.lockedByUsername = _data["lockedByUsername"];
            this.lockedByUserId = _data["lockedByUserId"];
            this.containerStatus = _data["containerStatus"];
            if (Array.isArray(_data["assignedUsers"])) {
                this.assignedUsers = [] as any;
                for (let item of _data["assignedUsers"])
                    this.assignedUsers!.push(item);
            }
        }
    }

    static fromJS(data: any): AccountsViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["status"] = this.status;
        data["gatewayConnected"] = this.gatewayConnected;
        data["tradingMode"] = this.tradingMode;
        data["accountType"] = this.accountType;
        data["isLocked"] = this.isLocked;
        data["lockedByUsername"] = this.lockedByUsername;
        data["lockedByUserId"] = this.lockedByUserId;
        data["containerStatus"] = this.containerStatus;
        if (Array.isArray(this.assignedUsers)) {
            data["assignedUsers"] = [];
            for (let item of this.assignedUsers)
                data["assignedUsers"].push(item);
        }
        return data;
    }
}

export interface IAccountsViewModel {
    id?: string | undefined;
    username?: string | undefined;
    status: AccountStatus;
    gatewayConnected: boolean;
    tradingMode: TradingMode;
    accountType: AccountType;
    isLocked: boolean;
    lockedByUsername?: string | undefined;
    lockedByUserId: string;
    containerStatus?: VMContainerStatus | undefined;
    assignedUsers?: string[] | undefined;
}

export enum AccountStatus {
    Stopped = "Stopped",
    Active = "Active",
}

export enum TradingMode {
    Paper = "Paper",
    Live = "Live",
}

export enum AccountType {
    IB = "IB",
    TDA = "TDA",
}

export enum VMContainerStatus {
    Provisioning = "Provisioning",
    Staging = "Staging",
    Running = "Running",
    Stopping = "Stopping",
    Repairing = "Repairing",
    Terminated = "Terminated",
    Suspending = "Suspending",
    Suspended = "Suspended",
    Unknown = "Unknown",
}

export class ErrorResultModel implements IErrorResultModel {
    errors?: string[] | undefined;
    validationErrors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IErrorResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (_data["validationErrors"]) {
                this.validationErrors = {} as any;
                for (let key in _data["validationErrors"]) {
                    if (_data["validationErrors"].hasOwnProperty(key))
                        (<any>this.validationErrors)![key] = _data["validationErrors"][key] !== undefined ? _data["validationErrors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ErrorResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (this.validationErrors) {
            data["validationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    (<any>data["validationErrors"])[key] = this.validationErrors[key];
            }
        }
        return data;
    }
}

export interface IErrorResultModel {
    errors?: string[] | undefined;
    validationErrors?: { [key: string]: string[]; } | undefined;
}

export class AccountsQuery implements IAccountsQuery {
    take!: number;
    skip!: number;

    constructor(data?: IAccountsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.take = _data["take"];
            this.skip = _data["skip"];
        }
    }

    static fromJS(data: any): AccountsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["take"] = this.take;
        data["skip"] = this.skip;
        return data;
    }
}

export interface IAccountsQuery {
    take: number;
    skip: number;
}

export class CreateAccountPostModel implements ICreateAccountPostModel {
    username!: string;
    password!: string;
    tradingMode!: TradingMode;

    constructor(data?: ICreateAccountPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.tradingMode = _data["tradingMode"];
        }
    }

    static fromJS(data: any): CreateAccountPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["tradingMode"] = this.tradingMode;
        return data;
    }
}

export interface ICreateAccountPostModel {
    username: string;
    password: string;
    tradingMode: TradingMode;
}

export class AssignUsersPostModel implements IAssignUsersPostModel {
    accountId!: string;
    assignedUsers?: string[] | undefined;

    constructor(data?: IAssignUsersPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["assignedUsers"])) {
                this.assignedUsers = [] as any;
                for (let item of _data["assignedUsers"])
                    this.assignedUsers!.push(item);
            }
        }
    }

    static fromJS(data: any): AssignUsersPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUsersPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        if (Array.isArray(this.assignedUsers)) {
            data["assignedUsers"] = [];
            for (let item of this.assignedUsers)
                data["assignedUsers"].push(item);
        }
        return data;
    }
}

export interface IAssignUsersPostModel {
    accountId: string;
    assignedUsers?: string[] | undefined;
}

export class PnlResponseModel implements IPnlResponseModel {
    account?: string | undefined;
    totalCashValue?: number | undefined;
    dailyPnL?: number | undefined;
    unrealizedPnL?: number | undefined;
    realizedPnL?: number | undefined;

    constructor(data?: IPnlResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.totalCashValue = _data["totalCashValue"];
            this.dailyPnL = _data["dailyPnL"];
            this.unrealizedPnL = _data["unrealizedPnL"];
            this.realizedPnL = _data["realizedPnL"];
        }
    }

    static fromJS(data: any): PnlResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PnlResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["totalCashValue"] = this.totalCashValue;
        data["dailyPnL"] = this.dailyPnL;
        data["unrealizedPnL"] = this.unrealizedPnL;
        data["realizedPnL"] = this.realizedPnL;
        return data;
    }
}

export interface IPnlResponseModel {
    account?: string | undefined;
    totalCashValue?: number | undefined;
    dailyPnL?: number | undefined;
    unrealizedPnL?: number | undefined;
    realizedPnL?: number | undefined;
}

export class UpdatePortfolioMessage implements IUpdatePortfolioMessage {
    contract?: Contract | undefined;
    position!: number;
    marketPrice!: number;
    marketValue!: number;
    averageCost!: number;
    unrealizedPNL!: number;
    realizedPNL!: number;
    accountName?: string | undefined;

    constructor(data?: IUpdatePortfolioMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : <any>undefined;
            this.position = _data["position"];
            this.marketPrice = _data["marketPrice"];
            this.marketValue = _data["marketValue"];
            this.averageCost = _data["averageCost"];
            this.unrealizedPNL = _data["unrealizedPNL"];
            this.realizedPNL = _data["realizedPNL"];
            this.accountName = _data["accountName"];
        }
    }

    static fromJS(data: any): UpdatePortfolioMessage {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePortfolioMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["marketPrice"] = this.marketPrice;
        data["marketValue"] = this.marketValue;
        data["averageCost"] = this.averageCost;
        data["unrealizedPNL"] = this.unrealizedPNL;
        data["realizedPNL"] = this.realizedPNL;
        data["accountName"] = this.accountName;
        return data;
    }
}

export interface IUpdatePortfolioMessage {
    contract?: Contract | undefined;
    position: number;
    marketPrice: number;
    marketValue: number;
    averageCost: number;
    unrealizedPNL: number;
    realizedPNL: number;
    accountName?: string | undefined;
}

export class Contract implements IContract {
    conId!: number;
    symbol?: string | undefined;
    secType?: string | undefined;
    lastTradeDateOrContractMonth?: string | undefined;
    strike!: number;
    right?: string | undefined;
    multiplier?: string | undefined;
    exchange?: string | undefined;
    currency?: string | undefined;
    localSymbol?: string | undefined;
    primaryExch?: string | undefined;
    tradingClass?: string | undefined;
    includeExpired!: boolean;
    secIdType?: string | undefined;
    secId?: string | undefined;
    comboLegsDescription?: string | undefined;
    comboLegs?: ComboLeg[] | undefined;
    deltaNeutralContract?: DeltaNeutralContract | undefined;

    constructor(data?: IContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conId = _data["conId"];
            this.symbol = _data["symbol"];
            this.secType = _data["secType"];
            this.lastTradeDateOrContractMonth = _data["lastTradeDateOrContractMonth"];
            this.strike = _data["strike"];
            this.right = _data["right"];
            this.multiplier = _data["multiplier"];
            this.exchange = _data["exchange"];
            this.currency = _data["currency"];
            this.localSymbol = _data["localSymbol"];
            this.primaryExch = _data["primaryExch"];
            this.tradingClass = _data["tradingClass"];
            this.includeExpired = _data["includeExpired"];
            this.secIdType = _data["secIdType"];
            this.secId = _data["secId"];
            this.comboLegsDescription = _data["comboLegsDescription"];
            if (Array.isArray(_data["comboLegs"])) {
                this.comboLegs = [] as any;
                for (let item of _data["comboLegs"])
                    this.comboLegs!.push(ComboLeg.fromJS(item));
            }
            this.deltaNeutralContract = _data["deltaNeutralContract"] ? DeltaNeutralContract.fromJS(_data["deltaNeutralContract"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Contract {
        data = typeof data === 'object' ? data : {};
        let result = new Contract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conId"] = this.conId;
        data["symbol"] = this.symbol;
        data["secType"] = this.secType;
        data["lastTradeDateOrContractMonth"] = this.lastTradeDateOrContractMonth;
        data["strike"] = this.strike;
        data["right"] = this.right;
        data["multiplier"] = this.multiplier;
        data["exchange"] = this.exchange;
        data["currency"] = this.currency;
        data["localSymbol"] = this.localSymbol;
        data["primaryExch"] = this.primaryExch;
        data["tradingClass"] = this.tradingClass;
        data["includeExpired"] = this.includeExpired;
        data["secIdType"] = this.secIdType;
        data["secId"] = this.secId;
        data["comboLegsDescription"] = this.comboLegsDescription;
        if (Array.isArray(this.comboLegs)) {
            data["comboLegs"] = [];
            for (let item of this.comboLegs)
                data["comboLegs"].push(item.toJSON());
        }
        data["deltaNeutralContract"] = this.deltaNeutralContract ? this.deltaNeutralContract.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContract {
    conId: number;
    symbol?: string | undefined;
    secType?: string | undefined;
    lastTradeDateOrContractMonth?: string | undefined;
    strike: number;
    right?: string | undefined;
    multiplier?: string | undefined;
    exchange?: string | undefined;
    currency?: string | undefined;
    localSymbol?: string | undefined;
    primaryExch?: string | undefined;
    tradingClass?: string | undefined;
    includeExpired: boolean;
    secIdType?: string | undefined;
    secId?: string | undefined;
    comboLegsDescription?: string | undefined;
    comboLegs?: ComboLeg[] | undefined;
    deltaNeutralContract?: DeltaNeutralContract | undefined;
}

export class ComboLeg implements IComboLeg {
    conId!: number;
    ratio!: number;
    action?: string | undefined;
    exchange?: string | undefined;
    openClose!: number;
    shortSaleSlot!: number;
    designatedLocation?: string | undefined;
    exemptCode!: number;

    constructor(data?: IComboLeg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conId = _data["conId"];
            this.ratio = _data["ratio"];
            this.action = _data["action"];
            this.exchange = _data["exchange"];
            this.openClose = _data["openClose"];
            this.shortSaleSlot = _data["shortSaleSlot"];
            this.designatedLocation = _data["designatedLocation"];
            this.exemptCode = _data["exemptCode"];
        }
    }

    static fromJS(data: any): ComboLeg {
        data = typeof data === 'object' ? data : {};
        let result = new ComboLeg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conId"] = this.conId;
        data["ratio"] = this.ratio;
        data["action"] = this.action;
        data["exchange"] = this.exchange;
        data["openClose"] = this.openClose;
        data["shortSaleSlot"] = this.shortSaleSlot;
        data["designatedLocation"] = this.designatedLocation;
        data["exemptCode"] = this.exemptCode;
        return data;
    }
}

export interface IComboLeg {
    conId: number;
    ratio: number;
    action?: string | undefined;
    exchange?: string | undefined;
    openClose: number;
    shortSaleSlot: number;
    designatedLocation?: string | undefined;
    exemptCode: number;
}

export class DeltaNeutralContract implements IDeltaNeutralContract {
    conId!: number;
    delta!: number;
    price!: number;

    constructor(data?: IDeltaNeutralContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conId = _data["conId"];
            this.delta = _data["delta"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): DeltaNeutralContract {
        data = typeof data === 'object' ? data : {};
        let result = new DeltaNeutralContract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conId"] = this.conId;
        data["delta"] = this.delta;
        data["price"] = this.price;
        return data;
    }
}

export interface IDeltaNeutralContract {
    conId: number;
    delta: number;
    price: number;
}

export class LoginResponseModel implements ILoginResponseModel {
    userId?: string | undefined;
    displayName?: string | undefined;
    token?: string | undefined;
    isAdmin!: boolean;

    constructor(data?: ILoginResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.displayName = _data["displayName"];
            this.token = _data["token"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): LoginResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["displayName"] = this.displayName;
        data["token"] = this.token;
        data["isAdmin"] = this.isAdmin;
        return data;
    }
}

export interface ILoginResponseModel {
    userId?: string | undefined;
    displayName?: string | undefined;
    token?: string | undefined;
    isAdmin: boolean;
}

export class LoginRequestModel implements ILoginRequestModel {
    email!: string;
    password!: string;

    constructor(data?: ILoginRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequestModel {
    email: string;
    password: string;
}

export class CreateUserRequest implements ICreateUserRequest {
    displayName!: string;
    email!: string;
    password!: string;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            this.password = _data["password"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["password"] = this.password;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserRequest {
    displayName: string;
    email: string;
    password: string;
    roles?: string[] | undefined;
}

export class ContainerStatusViewModel implements IContainerStatusViewModel {
    vmStatus!: VMContainerStatus;
    ibControllerStatus!: IBControllerStatus;
    address?: string | undefined;
    port?: string | undefined;
    tradingMode!: TradingMode;

    constructor(data?: IContainerStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vmStatus = _data["vmStatus"];
            this.ibControllerStatus = _data["ibControllerStatus"];
            this.address = _data["address"];
            this.port = _data["port"];
            this.tradingMode = _data["tradingMode"];
        }
    }

    static fromJS(data: any): ContainerStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vmStatus"] = this.vmStatus;
        data["ibControllerStatus"] = this.ibControllerStatus;
        data["address"] = this.address;
        data["port"] = this.port;
        data["tradingMode"] = this.tradingMode;
        return data;
    }
}

export interface IContainerStatusViewModel {
    vmStatus: VMContainerStatus;
    ibControllerStatus: IBControllerStatus;
    address?: string | undefined;
    port?: string | undefined;
    tradingMode: TradingMode;
}

export enum IBControllerStatus {
    WaitingToStart = "WaitingToStart",
    Available = "Available",
    FailedToStart = "FailedToStart",
    LoginFailed = "LoginFailed",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ContainerDetailsModel implements IContainerDetailsModel {
    accountName?: string | undefined;
    vmStatus!: VMContainerStatus;
    address?: string | undefined;
    port?: string | undefined;
    tradingMode!: TradingMode;

    constructor(data?: IContainerDetailsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountName = _data["accountName"];
            this.vmStatus = _data["vmStatus"];
            this.address = _data["address"];
            this.port = _data["port"];
            this.tradingMode = _data["tradingMode"];
        }
    }

    static fromJS(data: any): ContainerDetailsModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerDetailsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["vmStatus"] = this.vmStatus;
        data["address"] = this.address;
        data["port"] = this.port;
        data["tradingMode"] = this.tradingMode;
        return data;
    }
}

export interface IContainerDetailsModel {
    accountName?: string | undefined;
    vmStatus: VMContainerStatus;
    address?: string | undefined;
    port?: string | undefined;
    tradingMode: TradingMode;
}

export class TickModel implements ITickModel {
    tickByTickAllLastMessage?: TickByTickAllLastMessage | undefined;
    tickByTickBidAskMessage?: TickByTickBidAskMessage | undefined;
    tickByTickMidPointMessage?: TickByTickMidPointMessage | undefined;
    tickOptionMessage?: TickOptionMessage | undefined;
    tickPriceMessage?: TickPriceMessage | undefined;
    tickReqParamsMessage?: TickReqParamsMessage | undefined;
    tickSizeMessage?: TickSizeMessage | undefined;

    constructor(data?: ITickModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tickByTickAllLastMessage = _data["tickByTickAllLastMessage"] ? TickByTickAllLastMessage.fromJS(_data["tickByTickAllLastMessage"]) : <any>undefined;
            this.tickByTickBidAskMessage = _data["tickByTickBidAskMessage"] ? TickByTickBidAskMessage.fromJS(_data["tickByTickBidAskMessage"]) : <any>undefined;
            this.tickByTickMidPointMessage = _data["tickByTickMidPointMessage"] ? TickByTickMidPointMessage.fromJS(_data["tickByTickMidPointMessage"]) : <any>undefined;
            this.tickOptionMessage = _data["tickOptionMessage"] ? TickOptionMessage.fromJS(_data["tickOptionMessage"]) : <any>undefined;
            this.tickPriceMessage = _data["tickPriceMessage"] ? TickPriceMessage.fromJS(_data["tickPriceMessage"]) : <any>undefined;
            this.tickReqParamsMessage = _data["tickReqParamsMessage"] ? TickReqParamsMessage.fromJS(_data["tickReqParamsMessage"]) : <any>undefined;
            this.tickSizeMessage = _data["tickSizeMessage"] ? TickSizeMessage.fromJS(_data["tickSizeMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TickModel {
        data = typeof data === 'object' ? data : {};
        let result = new TickModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tickByTickAllLastMessage"] = this.tickByTickAllLastMessage ? this.tickByTickAllLastMessage.toJSON() : <any>undefined;
        data["tickByTickBidAskMessage"] = this.tickByTickBidAskMessage ? this.tickByTickBidAskMessage.toJSON() : <any>undefined;
        data["tickByTickMidPointMessage"] = this.tickByTickMidPointMessage ? this.tickByTickMidPointMessage.toJSON() : <any>undefined;
        data["tickOptionMessage"] = this.tickOptionMessage ? this.tickOptionMessage.toJSON() : <any>undefined;
        data["tickPriceMessage"] = this.tickPriceMessage ? this.tickPriceMessage.toJSON() : <any>undefined;
        data["tickReqParamsMessage"] = this.tickReqParamsMessage ? this.tickReqParamsMessage.toJSON() : <any>undefined;
        data["tickSizeMessage"] = this.tickSizeMessage ? this.tickSizeMessage.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITickModel {
    tickByTickAllLastMessage?: TickByTickAllLastMessage | undefined;
    tickByTickBidAskMessage?: TickByTickBidAskMessage | undefined;
    tickByTickMidPointMessage?: TickByTickMidPointMessage | undefined;
    tickOptionMessage?: TickOptionMessage | undefined;
    tickPriceMessage?: TickPriceMessage | undefined;
    tickReqParamsMessage?: TickReqParamsMessage | undefined;
    tickSizeMessage?: TickSizeMessage | undefined;
}

export class TickByTickAllLastMessage implements ITickByTickAllLastMessage {
    reqId!: number;
    tickType!: number;
    time!: number;
    price!: number;
    size!: number;
    tickAttribLast?: TickAttribLast | undefined;
    exchange?: string | undefined;
    specialConditions?: string | undefined;

    constructor(data?: ITickByTickAllLastMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reqId = _data["reqId"];
            this.tickType = _data["tickType"];
            this.time = _data["time"];
            this.price = _data["price"];
            this.size = _data["size"];
            this.tickAttribLast = _data["tickAttribLast"] ? TickAttribLast.fromJS(_data["tickAttribLast"]) : <any>undefined;
            this.exchange = _data["exchange"];
            this.specialConditions = _data["specialConditions"];
        }
    }

    static fromJS(data: any): TickByTickAllLastMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickByTickAllLastMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqId"] = this.reqId;
        data["tickType"] = this.tickType;
        data["time"] = this.time;
        data["price"] = this.price;
        data["size"] = this.size;
        data["tickAttribLast"] = this.tickAttribLast ? this.tickAttribLast.toJSON() : <any>undefined;
        data["exchange"] = this.exchange;
        data["specialConditions"] = this.specialConditions;
        return data;
    }
}

export interface ITickByTickAllLastMessage {
    reqId: number;
    tickType: number;
    time: number;
    price: number;
    size: number;
    tickAttribLast?: TickAttribLast | undefined;
    exchange?: string | undefined;
    specialConditions?: string | undefined;
}

export class TickAttribLast implements ITickAttribLast {
    pastLimit!: boolean;
    unreported!: boolean;

    constructor(data?: ITickAttribLast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pastLimit = _data["pastLimit"];
            this.unreported = _data["unreported"];
        }
    }

    static fromJS(data: any): TickAttribLast {
        data = typeof data === 'object' ? data : {};
        let result = new TickAttribLast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pastLimit"] = this.pastLimit;
        data["unreported"] = this.unreported;
        return data;
    }
}

export interface ITickAttribLast {
    pastLimit: boolean;
    unreported: boolean;
}

export class TickByTickBidAskMessage implements ITickByTickBidAskMessage {
    reqId!: number;
    time!: number;
    bidPrice!: number;
    askPrice!: number;
    bidSize!: number;
    askSize!: number;
    tickAttribBidAsk?: TickAttribBidAsk | undefined;

    constructor(data?: ITickByTickBidAskMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reqId = _data["reqId"];
            this.time = _data["time"];
            this.bidPrice = _data["bidPrice"];
            this.askPrice = _data["askPrice"];
            this.bidSize = _data["bidSize"];
            this.askSize = _data["askSize"];
            this.tickAttribBidAsk = _data["tickAttribBidAsk"] ? TickAttribBidAsk.fromJS(_data["tickAttribBidAsk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TickByTickBidAskMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickByTickBidAskMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqId"] = this.reqId;
        data["time"] = this.time;
        data["bidPrice"] = this.bidPrice;
        data["askPrice"] = this.askPrice;
        data["bidSize"] = this.bidSize;
        data["askSize"] = this.askSize;
        data["tickAttribBidAsk"] = this.tickAttribBidAsk ? this.tickAttribBidAsk.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITickByTickBidAskMessage {
    reqId: number;
    time: number;
    bidPrice: number;
    askPrice: number;
    bidSize: number;
    askSize: number;
    tickAttribBidAsk?: TickAttribBidAsk | undefined;
}

export class TickAttribBidAsk implements ITickAttribBidAsk {
    bidPastLow!: boolean;
    askPastHigh!: boolean;

    constructor(data?: ITickAttribBidAsk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bidPastLow = _data["bidPastLow"];
            this.askPastHigh = _data["askPastHigh"];
        }
    }

    static fromJS(data: any): TickAttribBidAsk {
        data = typeof data === 'object' ? data : {};
        let result = new TickAttribBidAsk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bidPastLow"] = this.bidPastLow;
        data["askPastHigh"] = this.askPastHigh;
        return data;
    }
}

export interface ITickAttribBidAsk {
    bidPastLow: boolean;
    askPastHigh: boolean;
}

export class TickByTickMidPointMessage implements ITickByTickMidPointMessage {
    reqId!: number;
    time!: number;
    midPoint!: number;

    constructor(data?: ITickByTickMidPointMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reqId = _data["reqId"];
            this.time = _data["time"];
            this.midPoint = _data["midPoint"];
        }
    }

    static fromJS(data: any): TickByTickMidPointMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickByTickMidPointMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reqId"] = this.reqId;
        data["time"] = this.time;
        data["midPoint"] = this.midPoint;
        return data;
    }
}

export interface ITickByTickMidPointMessage {
    reqId: number;
    time: number;
    midPoint: number;
}

export abstract class MarketDataMessage implements IMarketDataMessage {
    requestId!: number;
    field!: number;

    constructor(data?: IMarketDataMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.field = _data["field"];
        }
    }

    static fromJS(data: any): MarketDataMessage {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MarketDataMessage' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["field"] = this.field;
        return data;
    }
}

export interface IMarketDataMessage {
    requestId: number;
    field: number;
}

export class TickOptionMessage extends MarketDataMessage implements ITickOptionMessage {
    tickAttrib!: number;
    impliedVolatility!: number;
    delta!: number;
    optPrice!: number;
    pvDividend!: number;
    gamma!: number;
    vega!: number;
    theta!: number;
    undPrice!: number;

    constructor(data?: ITickOptionMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tickAttrib = _data["tickAttrib"];
            this.impliedVolatility = _data["impliedVolatility"];
            this.delta = _data["delta"];
            this.optPrice = _data["optPrice"];
            this.pvDividend = _data["pvDividend"];
            this.gamma = _data["gamma"];
            this.vega = _data["vega"];
            this.theta = _data["theta"];
            this.undPrice = _data["undPrice"];
        }
    }

    static fromJS(data: any): TickOptionMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickOptionMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tickAttrib"] = this.tickAttrib;
        data["impliedVolatility"] = this.impliedVolatility;
        data["delta"] = this.delta;
        data["optPrice"] = this.optPrice;
        data["pvDividend"] = this.pvDividend;
        data["gamma"] = this.gamma;
        data["vega"] = this.vega;
        data["theta"] = this.theta;
        data["undPrice"] = this.undPrice;
        super.toJSON(data);
        return data;
    }
}

export interface ITickOptionMessage extends IMarketDataMessage {
    tickAttrib: number;
    impliedVolatility: number;
    delta: number;
    optPrice: number;
    pvDividend: number;
    gamma: number;
    vega: number;
    theta: number;
    undPrice: number;
}

export class TickPriceMessage extends MarketDataMessage implements ITickPriceMessage {
    attribs?: TickAttrib | undefined;
    price!: number;

    constructor(data?: ITickPriceMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attribs = _data["attribs"] ? TickAttrib.fromJS(_data["attribs"]) : <any>undefined;
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): TickPriceMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickPriceMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attribs"] = this.attribs ? this.attribs.toJSON() : <any>undefined;
        data["price"] = this.price;
        super.toJSON(data);
        return data;
    }
}

export interface ITickPriceMessage extends IMarketDataMessage {
    attribs?: TickAttrib | undefined;
    price: number;
}

export class TickAttrib implements ITickAttrib {
    canAutoExecute!: boolean;
    pastLimit!: boolean;
    preOpen!: boolean;
    unreported!: boolean;
    bidPastLow!: boolean;
    askPastHigh!: boolean;

    constructor(data?: ITickAttrib) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canAutoExecute = _data["canAutoExecute"];
            this.pastLimit = _data["pastLimit"];
            this.preOpen = _data["preOpen"];
            this.unreported = _data["unreported"];
            this.bidPastLow = _data["bidPastLow"];
            this.askPastHigh = _data["askPastHigh"];
        }
    }

    static fromJS(data: any): TickAttrib {
        data = typeof data === 'object' ? data : {};
        let result = new TickAttrib();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canAutoExecute"] = this.canAutoExecute;
        data["pastLimit"] = this.pastLimit;
        data["preOpen"] = this.preOpen;
        data["unreported"] = this.unreported;
        data["bidPastLow"] = this.bidPastLow;
        data["askPastHigh"] = this.askPastHigh;
        return data;
    }
}

export interface ITickAttrib {
    canAutoExecute: boolean;
    pastLimit: boolean;
    preOpen: boolean;
    unreported: boolean;
    bidPastLow: boolean;
    askPastHigh: boolean;
}

export class TickReqParamsMessage implements ITickReqParamsMessage {
    tickerId!: number;
    minTick!: number;
    bboExchange?: string | undefined;
    snapshotPermissions!: number;

    constructor(data?: ITickReqParamsMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tickerId = _data["tickerId"];
            this.minTick = _data["minTick"];
            this.bboExchange = _data["bboExchange"];
            this.snapshotPermissions = _data["snapshotPermissions"];
        }
    }

    static fromJS(data: any): TickReqParamsMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickReqParamsMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tickerId"] = this.tickerId;
        data["minTick"] = this.minTick;
        data["bboExchange"] = this.bboExchange;
        data["snapshotPermissions"] = this.snapshotPermissions;
        return data;
    }
}

export interface ITickReqParamsMessage {
    tickerId: number;
    minTick: number;
    bboExchange?: string | undefined;
    snapshotPermissions: number;
}

export class TickSizeMessage extends MarketDataMessage implements ITickSizeMessage {
    size!: number;

    constructor(data?: ITickSizeMessage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): TickSizeMessage {
        data = typeof data === 'object' ? data : {};
        let result = new TickSizeMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size;
        super.toJSON(data);
        return data;
    }
}

export interface ITickSizeMessage extends IMarketDataMessage {
    size: number;
}

export class OrderViewModel implements IOrderViewModel {
    account?: string | undefined;
    orderId!: number;
    tradeId!: string;
    size!: number;
    orderStatus!: OrderStatus;
    filledQuantityPercentage!: number;
    timeInForce!: TimeInForce;
    executionType!: ExecutionType;
    orderType!: OrderType;
    adaptivePriority?: AdaptivePriority | undefined;
    action?: string | undefined;
    price?: number | undefined;
    lmtPrice?: number | undefined;
    trailingPercent?: number | undefined;
    trailStopPrice?: number | undefined;
    timeStop?: string | undefined;

    constructor(data?: IOrderViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.orderId = _data["orderId"];
            this.tradeId = _data["tradeId"];
            this.size = _data["size"];
            this.orderStatus = _data["orderStatus"];
            this.filledQuantityPercentage = _data["filledQuantityPercentage"];
            this.timeInForce = _data["timeInForce"];
            this.executionType = _data["executionType"];
            this.orderType = _data["orderType"];
            this.adaptivePriority = _data["adaptivePriority"];
            this.action = _data["action"];
            this.price = _data["price"];
            this.lmtPrice = _data["lmtPrice"];
            this.trailingPercent = _data["trailingPercent"];
            this.trailStopPrice = _data["trailStopPrice"];
            this.timeStop = _data["timeStop"];
        }
    }

    static fromJS(data: any): OrderViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["orderId"] = this.orderId;
        data["tradeId"] = this.tradeId;
        data["size"] = this.size;
        data["orderStatus"] = this.orderStatus;
        data["filledQuantityPercentage"] = this.filledQuantityPercentage;
        data["timeInForce"] = this.timeInForce;
        data["executionType"] = this.executionType;
        data["orderType"] = this.orderType;
        data["adaptivePriority"] = this.adaptivePriority;
        data["action"] = this.action;
        data["price"] = this.price;
        data["lmtPrice"] = this.lmtPrice;
        data["trailingPercent"] = this.trailingPercent;
        data["trailStopPrice"] = this.trailStopPrice;
        data["timeStop"] = this.timeStop;
        return data;
    }
}

export interface IOrderViewModel {
    account?: string | undefined;
    orderId: number;
    tradeId: string;
    size: number;
    orderStatus: OrderStatus;
    filledQuantityPercentage: number;
    timeInForce: TimeInForce;
    executionType: ExecutionType;
    orderType: OrderType;
    adaptivePriority?: AdaptivePriority | undefined;
    action?: string | undefined;
    price?: number | undefined;
    lmtPrice?: number | undefined;
    trailingPercent?: number | undefined;
    trailStopPrice?: number | undefined;
    timeStop?: string | undefined;
}

export enum OrderStatus {
    Open = "Open",
    Rejected = "Rejected",
    PartiallyFilled = "PartiallyFilled",
    Filled = "Filled",
    Cancelled = "Cancelled",
}

export enum TimeInForce {
    DAY = "DAY",
    GTC = "GTC",
}

export enum ExecutionType {
    MKT = "MKT",
    LMT = "LMT",
    MIDPRICE = "MIDPRICE",
    STP = "STP",
}

export enum OrderType {
    TRADE = "TRADE",
    TAKE_PROFIT = "TAKE_PROFIT",
    STOP_LOSS = "STOP_LOSS",
    TRAILING_STOP_LOSS = "TRAILING_STOP_LOSS",
    TIME_STOP = "TIME_STOP",
}

export enum AdaptivePriority {
    Urgent = "Urgent",
    Normal = "Normal",
    Patient = "Patient",
}

export class CreateOrderPostModel implements ICreateOrderPostModel {
    tradeId!: string;
    size!: number;
    timeInForce!: TimeInForce;
    executionType!: ExecutionType;
    orderType!: OrderType;
    quote?: QuotePostModel | undefined;

    constructor(data?: ICreateOrderPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tradeId = _data["tradeId"];
            this.size = _data["size"];
            this.timeInForce = _data["timeInForce"];
            this.executionType = _data["executionType"];
            this.orderType = _data["orderType"];
            this.quote = _data["quote"] ? QuotePostModel.fromJS(_data["quote"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrderPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tradeId"] = this.tradeId;
        data["size"] = this.size;
        data["timeInForce"] = this.timeInForce;
        data["executionType"] = this.executionType;
        data["orderType"] = this.orderType;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrderPostModel {
    tradeId: string;
    size: number;
    timeInForce: TimeInForce;
    executionType: ExecutionType;
    orderType: OrderType;
    quote?: QuotePostModel | undefined;
}

export class QuotePostModel implements IQuotePostModel {
    symbol?: string | undefined;
    secType?: string | undefined;
    strike!: number;
    expirationDate?: string | undefined;
    right?: string | undefined;
    description?: string | undefined;

    constructor(data?: IQuotePostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.secType = _data["secType"];
            this.strike = _data["strike"];
            this.expirationDate = _data["expirationDate"];
            this.right = _data["right"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): QuotePostModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuotePostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["secType"] = this.secType;
        data["strike"] = this.strike;
        data["expirationDate"] = this.expirationDate;
        data["right"] = this.right;
        data["description"] = this.description;
        return data;
    }
}

export interface IQuotePostModel {
    symbol?: string | undefined;
    secType?: string | undefined;
    strike: number;
    expirationDate?: string | undefined;
    right?: string | undefined;
    description?: string | undefined;
}

export class GetQuotesForSymbolsResult implements IGetQuotesForSymbolsResult {
    quotes?: QuoteResult[] | undefined;

    constructor(data?: IGetQuotesForSymbolsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["quotes"])) {
                this.quotes = [] as any;
                for (let item of _data["quotes"])
                    this.quotes!.push(QuoteResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetQuotesForSymbolsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotesForSymbolsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.quotes)) {
            data["quotes"] = [];
            for (let item of this.quotes)
                data["quotes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetQuotesForSymbolsResult {
    quotes?: QuoteResult[] | undefined;
}

export class QuoteResult implements IQuoteResult {
    volume?: string | undefined;
    ask?: string | undefined;
    bid?: string | undefined;
    description?: string | undefined;
    midPrice?: string | undefined;
    last?: string | undefined;
    symbol?: string | undefined;
    secType?: string | undefined;
    expirationDate?: string | undefined;
    close?: string | undefined;
    low?: string | undefined;
    high?: string | undefined;
    openChangePercent?: string | undefined;
    open?: string | undefined;
    undPrice?: string | undefined;
    multiplier!: number;

    constructor(data?: IQuoteResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.volume = _data["volume"];
            this.ask = _data["ask"];
            this.bid = _data["bid"];
            this.description = _data["description"];
            this.midPrice = _data["midPrice"];
            this.last = _data["last"];
            this.symbol = _data["symbol"];
            this.secType = _data["secType"];
            this.expirationDate = _data["expirationDate"];
            this.close = _data["close"];
            this.low = _data["low"];
            this.high = _data["high"];
            this.openChangePercent = _data["openChangePercent"];
            this.open = _data["open"];
            this.undPrice = _data["undPrice"];
            this.multiplier = _data["multiplier"];
        }
    }

    static fromJS(data: any): QuoteResult {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["volume"] = this.volume;
        data["ask"] = this.ask;
        data["bid"] = this.bid;
        data["description"] = this.description;
        data["midPrice"] = this.midPrice;
        data["last"] = this.last;
        data["symbol"] = this.symbol;
        data["secType"] = this.secType;
        data["expirationDate"] = this.expirationDate;
        data["close"] = this.close;
        data["low"] = this.low;
        data["high"] = this.high;
        data["openChangePercent"] = this.openChangePercent;
        data["open"] = this.open;
        data["undPrice"] = this.undPrice;
        data["multiplier"] = this.multiplier;
        return data;
    }
}

export interface IQuoteResult {
    volume?: string | undefined;
    ask?: string | undefined;
    bid?: string | undefined;
    description?: string | undefined;
    midPrice?: string | undefined;
    last?: string | undefined;
    symbol?: string | undefined;
    secType?: string | undefined;
    expirationDate?: string | undefined;
    close?: string | undefined;
    low?: string | undefined;
    high?: string | undefined;
    openChangePercent?: string | undefined;
    open?: string | undefined;
    undPrice?: string | undefined;
    multiplier: number;
}

export class QuoteQuery implements IQuoteQuery {
    secType?: string | undefined;
    symbol?: string | undefined;
    strike?: number | undefined;
    right?: string | undefined;
    expirationDate?: string | undefined;
    exchange?: string | undefined;

    constructor(data?: IQuoteQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secType = _data["secType"];
            this.symbol = _data["symbol"];
            this.strike = _data["strike"];
            this.right = _data["right"];
            this.expirationDate = _data["expirationDate"];
            this.exchange = _data["exchange"];
        }
    }

    static fromJS(data: any): QuoteQuery {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secType"] = this.secType;
        data["symbol"] = this.symbol;
        data["strike"] = this.strike;
        data["right"] = this.right;
        data["expirationDate"] = this.expirationDate;
        data["exchange"] = this.exchange;
        return data;
    }
}

export interface IQuoteQuery {
    secType?: string | undefined;
    symbol?: string | undefined;
    strike?: number | undefined;
    right?: string | undefined;
    expirationDate?: string | undefined;
    exchange?: string | undefined;
}

export class ExpirationsResponseModel implements IExpirationsResponseModel {
    expirations?: string[] | undefined;

    constructor(data?: IExpirationsResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expirations"])) {
                this.expirations = [] as any;
                for (let item of _data["expirations"])
                    this.expirations!.push(item);
            }
        }
    }

    static fromJS(data: any): ExpirationsResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExpirationsResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expirations)) {
            data["expirations"] = [];
            for (let item of this.expirations)
                data["expirations"].push(item);
        }
        return data;
    }
}

export interface IExpirationsResponseModel {
    expirations?: string[] | undefined;
}

export class OptionsWatchlistData implements IOptionsWatchlistData {
    id!: number;
    display?: string | undefined;
    strike?: string | undefined;
    expirationDate?: string | undefined;
    right?: string | undefined;
    volume?: string | undefined;
    ask?: string | undefined;
    bid?: string | undefined;
    last?: string | undefined;
    impliedVolatility?: string | undefined;
    delta?: string | undefined;
    gamma?: string | undefined;
    vega?: string | undefined;
    theta?: string | undefined;
    undPrice?: string | undefined;
    symbol?: string | undefined;
    previousClose?: string | undefined;
    low?: string | undefined;
    high?: string | undefined;
    openInterest?: string | undefined;
    openChangePercent?: string | undefined;
    open?: string | undefined;

    constructor(data?: IOptionsWatchlistData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.display = _data["display"];
            this.strike = _data["strike"];
            this.expirationDate = _data["expirationDate"];
            this.right = _data["right"];
            this.volume = _data["volume"];
            this.ask = _data["ask"];
            this.bid = _data["bid"];
            this.last = _data["last"];
            this.impliedVolatility = _data["impliedVolatility"];
            this.delta = _data["delta"];
            this.gamma = _data["gamma"];
            this.vega = _data["vega"];
            this.theta = _data["theta"];
            this.undPrice = _data["undPrice"];
            this.symbol = _data["symbol"];
            this.previousClose = _data["previousClose"];
            this.low = _data["low"];
            this.high = _data["high"];
            this.openInterest = _data["openInterest"];
            this.openChangePercent = _data["openChangePercent"];
            this.open = _data["open"];
        }
    }

    static fromJS(data: any): OptionsWatchlistData {
        data = typeof data === 'object' ? data : {};
        let result = new OptionsWatchlistData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["display"] = this.display;
        data["strike"] = this.strike;
        data["expirationDate"] = this.expirationDate;
        data["right"] = this.right;
        data["volume"] = this.volume;
        data["ask"] = this.ask;
        data["bid"] = this.bid;
        data["last"] = this.last;
        data["impliedVolatility"] = this.impliedVolatility;
        data["delta"] = this.delta;
        data["gamma"] = this.gamma;
        data["vega"] = this.vega;
        data["theta"] = this.theta;
        data["undPrice"] = this.undPrice;
        data["symbol"] = this.symbol;
        data["previousClose"] = this.previousClose;
        data["low"] = this.low;
        data["high"] = this.high;
        data["openInterest"] = this.openInterest;
        data["openChangePercent"] = this.openChangePercent;
        data["open"] = this.open;
        return data;
    }
}

export interface IOptionsWatchlistData {
    id: number;
    display?: string | undefined;
    strike?: string | undefined;
    expirationDate?: string | undefined;
    right?: string | undefined;
    volume?: string | undefined;
    ask?: string | undefined;
    bid?: string | undefined;
    last?: string | undefined;
    impliedVolatility?: string | undefined;
    delta?: string | undefined;
    gamma?: string | undefined;
    vega?: string | undefined;
    theta?: string | undefined;
    undPrice?: string | undefined;
    symbol?: string | undefined;
    previousClose?: string | undefined;
    low?: string | undefined;
    high?: string | undefined;
    openInterest?: string | undefined;
    openChangePercent?: string | undefined;
    open?: string | undefined;
}

export class SymbolSearchResult implements ISymbolSearchResult {
    results?: SymbolSearchResultItem[] | undefined;

    constructor(data?: ISymbolSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SymbolSearchResultItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SymbolSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISymbolSearchResult {
    results?: SymbolSearchResultItem[] | undefined;
}

export class SymbolSearchResultItem implements ISymbolSearchResultItem {
    symbol?: string | undefined;
    description?: string | undefined;
    expiration?: string | undefined;

    constructor(data?: ISymbolSearchResultItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.description = _data["description"];
            this.expiration = _data["expiration"];
        }
    }

    static fromJS(data: any): SymbolSearchResultItem {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolSearchResultItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["description"] = this.description;
        data["expiration"] = this.expiration;
        return data;
    }
}

export interface ISymbolSearchResultItem {
    symbol?: string | undefined;
    description?: string | undefined;
    expiration?: string | undefined;
}

export class TradeViewModel implements ITradeViewModel {
    tradeId!: string;
    thesis?: string | undefined;
    tradeType!: TradeType;
    quote?: Quote | undefined;
    displayHierarchy?: string[] | undefined;
    underlyingEntryPrice?: number | undefined;
    underlyingStopLoss?: number[] | undefined;
    underlyingTakeProfit?: number[] | undefined;
    tactic?: string | undefined;
    entryPrice?: number | undefined;
    exitPrice?: number | undefined;
    percentageSold?: number | undefined;
    entryDate?: string | undefined;
    exitDate?: string | undefined;
    size?: number | undefined;
    realized!: number;
    unrealized!: number;
    total!: number;
    shares!: number;
    averageOpenPrice!: number;
    notes?: string[] | undefined;

    constructor(data?: ITradeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tradeId = _data["tradeId"];
            this.thesis = _data["thesis"];
            this.tradeType = _data["tradeType"];
            this.quote = _data["quote"] ? Quote.fromJS(_data["quote"]) : <any>undefined;
            if (Array.isArray(_data["displayHierarchy"])) {
                this.displayHierarchy = [] as any;
                for (let item of _data["displayHierarchy"])
                    this.displayHierarchy!.push(item);
            }
            this.underlyingEntryPrice = _data["underlyingEntryPrice"];
            if (Array.isArray(_data["underlyingStopLoss"])) {
                this.underlyingStopLoss = [] as any;
                for (let item of _data["underlyingStopLoss"])
                    this.underlyingStopLoss!.push(item);
            }
            if (Array.isArray(_data["underlyingTakeProfit"])) {
                this.underlyingTakeProfit = [] as any;
                for (let item of _data["underlyingTakeProfit"])
                    this.underlyingTakeProfit!.push(item);
            }
            this.tactic = _data["tactic"];
            this.entryPrice = _data["entryPrice"];
            this.exitPrice = _data["exitPrice"];
            this.percentageSold = _data["percentageSold"];
            this.entryDate = _data["entryDate"];
            this.exitDate = _data["exitDate"];
            this.size = _data["size"];
            this.realized = _data["realized"];
            this.unrealized = _data["unrealized"];
            this.total = _data["total"];
            this.shares = _data["shares"];
            this.averageOpenPrice = _data["averageOpenPrice"];
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(item);
            }
        }
    }

    static fromJS(data: any): TradeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TradeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tradeId"] = this.tradeId;
        data["thesis"] = this.thesis;
        data["tradeType"] = this.tradeType;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        if (Array.isArray(this.displayHierarchy)) {
            data["displayHierarchy"] = [];
            for (let item of this.displayHierarchy)
                data["displayHierarchy"].push(item);
        }
        data["underlyingEntryPrice"] = this.underlyingEntryPrice;
        if (Array.isArray(this.underlyingStopLoss)) {
            data["underlyingStopLoss"] = [];
            for (let item of this.underlyingStopLoss)
                data["underlyingStopLoss"].push(item);
        }
        if (Array.isArray(this.underlyingTakeProfit)) {
            data["underlyingTakeProfit"] = [];
            for (let item of this.underlyingTakeProfit)
                data["underlyingTakeProfit"].push(item);
        }
        data["tactic"] = this.tactic;
        data["entryPrice"] = this.entryPrice;
        data["exitPrice"] = this.exitPrice;
        data["percentageSold"] = this.percentageSold;
        data["entryDate"] = this.entryDate;
        data["exitDate"] = this.exitDate;
        data["size"] = this.size;
        data["realized"] = this.realized;
        data["unrealized"] = this.unrealized;
        data["total"] = this.total;
        data["shares"] = this.shares;
        data["averageOpenPrice"] = this.averageOpenPrice;
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item);
        }
        return data;
    }
}

export interface ITradeViewModel {
    tradeId: string;
    thesis?: string | undefined;
    tradeType: TradeType;
    quote?: Quote | undefined;
    displayHierarchy?: string[] | undefined;
    underlyingEntryPrice?: number | undefined;
    underlyingStopLoss?: number[] | undefined;
    underlyingTakeProfit?: number[] | undefined;
    tactic?: string | undefined;
    entryPrice?: number | undefined;
    exitPrice?: number | undefined;
    percentageSold?: number | undefined;
    entryDate?: string | undefined;
    exitDate?: string | undefined;
    size?: number | undefined;
    realized: number;
    unrealized: number;
    total: number;
    shares: number;
    averageOpenPrice: number;
    notes?: string[] | undefined;
}

export enum TradeType {
    CHASE = "CHASE",
    SWING = "SWING",
    TREND = "TREND",
}

/** Inherit this class for all entities you want to store in their own collection. */
export abstract class Entity implements IEntity {
    /** This property is auto managed. A new ID will be assigned for new entities upon saving. */
    id?: string | undefined;

    constructor(data?: IEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Entity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** Inherit this class for all entities you want to store in their own collection. */
export interface IEntity {
    /** This property is auto managed. A new ID will be assigned for new entities upon saving. */
    id?: string | undefined;
}

export class Quote extends Entity implements IQuote {
    symbol?: string | undefined;
    secType?: string | undefined;
    strike!: number;
    expirationDate?: string | undefined;
    right?: string | undefined;
    description?: string | undefined;
    isOption!: boolean;

    constructor(data?: IQuote) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.symbol = _data["symbol"];
            this.secType = _data["secType"];
            this.strike = _data["strike"];
            this.expirationDate = _data["expirationDate"];
            this.right = _data["right"];
            this.description = _data["description"];
            this.isOption = _data["isOption"];
        }
    }

    static fromJS(data: any): Quote {
        data = typeof data === 'object' ? data : {};
        let result = new Quote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["secType"] = this.secType;
        data["strike"] = this.strike;
        data["expirationDate"] = this.expirationDate;
        data["right"] = this.right;
        data["description"] = this.description;
        data["isOption"] = this.isOption;
        super.toJSON(data);
        return data;
    }
}

export interface IQuote extends IEntity {
    symbol?: string | undefined;
    secType?: string | undefined;
    strike: number;
    expirationDate?: string | undefined;
    right?: string | undefined;
    description?: string | undefined;
    isOption: boolean;
}

export class CreateTradePostModel implements ICreateTradePostModel {
    tradeId!: string;
    account?: string | undefined;
    quote?: QuotePostModel | undefined;
    parentTradeId?: string | undefined;
    legs?: CreateTradePostModel[] | undefined;
    tradeType?: TradeType | undefined;
    thesis?: string | undefined;

    constructor(data?: ICreateTradePostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tradeId = _data["tradeId"];
            this.account = _data["account"];
            this.quote = _data["quote"] ? QuotePostModel.fromJS(_data["quote"]) : <any>undefined;
            this.parentTradeId = _data["parentTradeId"];
            if (Array.isArray(_data["legs"])) {
                this.legs = [] as any;
                for (let item of _data["legs"])
                    this.legs!.push(CreateTradePostModel.fromJS(item));
            }
            this.tradeType = _data["tradeType"];
            this.thesis = _data["thesis"];
        }
    }

    static fromJS(data: any): CreateTradePostModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTradePostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tradeId"] = this.tradeId;
        data["account"] = this.account;
        data["quote"] = this.quote ? this.quote.toJSON() : <any>undefined;
        data["parentTradeId"] = this.parentTradeId;
        if (Array.isArray(this.legs)) {
            data["legs"] = [];
            for (let item of this.legs)
                data["legs"].push(item.toJSON());
        }
        data["tradeType"] = this.tradeType;
        data["thesis"] = this.thesis;
        return data;
    }
}

export interface ICreateTradePostModel {
    tradeId: string;
    account?: string | undefined;
    quote?: QuotePostModel | undefined;
    parentTradeId?: string | undefined;
    legs?: CreateTradePostModel[] | undefined;
    tradeType?: TradeType | undefined;
    thesis?: string | undefined;
}

export class ApplicationUserViewModel implements IApplicationUserViewModel {
    id!: string;
    displayName?: string | undefined;

    constructor(data?: IApplicationUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ApplicationUserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IApplicationUserViewModel {
    id: string;
    displayName?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}